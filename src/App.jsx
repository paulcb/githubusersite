import { useEffect, useState } from 'react';
import './App.css'
import stat1 from './assets/trace_stats.png'
import stat2 from './assets/trace_error.png'
import Prism from "prismjs";

function App() {
  const [links, setLinks] = useState("");

  useEffect(() => {
    Prism.highlightAll();
  }, []);

  useEffect(() => {
    if (!links) {

      const appLink = import.meta.env.VITE_APP_LINK;
      const codeLink = import.meta.env.VITE_CODE_LINK;
      const linksFromEnv = { appLink: appLink, codeLink: codeLink };
      //unecessary link ascii encoding/decoding for run...
      // const val1Arry = new Uint8Array(val1.split(',').map(x => Number(x)));
      // const decodedVal1 = new TextDecoder().decode(val1Arry);
      setLinks(linksFromEnv);
    }
  }, [links]);

  let codeString = `
# process next cache request
def process_key(self, conn, key, count, threadNumber):
  stime = time.time()
  # is there a key already in the cache
  if conn.exists(key):
      value = json.loads(conn.get(key))
      self.log_cache(threadNumber, count, stime, key, value, True, False)
  else:
      # no key in the cache, so now grab the database value and populate the cache
      value = fetch_data(self.table_name, key, self.Session)
      self.log_cache(threadNumber, count, stime,
                      key, value, False, False)
      conn.set(key, json.dumps(value))
  `;

  return (
    <>
      <div className="card">
        <div className="cardDate">3/3/2025</div>
        <div style={{ display: 'inline' }}>
          <a className="carda" href={links.appLink}>
            aMazeThing
          </a>
          &nbsp;--&nbsp;
          <a className="carda" href={links.codeLink}>
            code
          </a>
        </div>
        <p>
          aMazeThing is a React Typescript AWS CloudFront powered website that give users endless mazes to solve over and over again!
          <br /><br />
          Users may select from replayable daily mazes that are generated by a AWS CDK Stack utilizing: Lambda, S3 Bucket, and EventBridge Scheduler.
          <br /><br />
          A daily maze is generated using an EventBridge Schedule Rule that triggers a Lambda function every 24 hours that writes to a S3 Bucket. The CloudFront site then reads mazes from the last ten days for users to select. Or a user may use the embedded TypeScript maze generator as many times as they want.
          <br /><br />
          Using AWS CodePipeline and Github, a seperate development evironment is used for creating feature changes before updating production instances providing CI/CD.
          A special case is handled for preserving the production S3 Bucket incase of production redeploy.
          <a>
            {/* aMazeThing Medium blog with more passion :) */}
          </a>

        </p>
      </div>
      <div className="card">
        <div className="cardDate">3/30/2025</div>
        <div style={{ display: 'inline' }}>
          <a className="carda" href={links.appLink}>
            I Dunno Here's Some Cache Stuff
          </a>
          &nbsp;--&nbsp;
          <a className="carda" href={links.codeLink}>
            code
          </a>
        </div>
        <p>
          Caching software like Redis and Memcached are gotos for speeding up requests between client and server. Lately, there have been examples showing PostgreSQL’s ability to cache data which might already exist in a platform's infrastructure. Using already existing infrastructure is a pragmatic way to gain performance. How does PostgreSQL’s cache mechanism compare to existing caching software?
          <br /><br />

          In this post, runtimes and mean response times for cache hits and misses are tested for four caching methods, Redis, Memcached, PostgreSQL Unlogged Table, and Python dictionary are analyzed. Single instances are used with Python multithreading to simulate concurrent requests. For realistic testing, trace files from “ARC: A SELF-TUNING, LOW OVERHEAD REPLACEMENT CACHE” (ARC paper) are used in testing [2]. Also, a few randomized trace files were generated.

          <br /><br />

          The caching design is hopefully familiar: database requests are retrieved to fill a cache for later requests. Moreover, a request specifies some identifier from the database. If the identifier didn’t already exist in that case, it’s retrieved from the data store and set in the cache. Since this blog post is just looking into response times a smaller static message size of 16 bytes was given to all trace file values. Making the test like cached website session tokens. In the ARC paper, trace file values depend on the second column for the number of blocks all 512 bytes in size.

          <br /><br />

          <pre>
            <code class="language-python">
              {codeString}
            </code>
          </pre>

          <br /><br />

          <img src={stat1} alt="logo" />

          <br /><br />

          Memcached has a significant write latency while giving the best read latency. Redis is overall probably the best choice since it offers best read and write latency. PostgreSQL is what one would expect, an OK choice.

          <br /><br />

          Here's an interesting issue that occurred with PostgreSQL.

          <br /><br />

          <img src={stat2} alt="logo" />

          <br /><br />

          Using the multithreaded requests, a missing key was attempting to write to the cache when another had already written at the same time. In this case, since this is only for testing purposes, the key is put back on the queue. The queuing is done by Python's queue library which is helpful when doing multithreaded processing since it has blocking and timeout features.

          <br /><br />

          Lastly, let’s do a more realistic queue situation that’s not just focused on response times. For PostgreSQL the pg_cron was enabled to start a cron job to clear the cache table of old records on a 20 minute timer. Since the S3.lis trace takes about 4 hours it seems reasonable. Really though, Redis and Memcache use some kind of least recently used (LRU) or least frequently used caching (LFU) method or maybe a mix like in the ARC paper.

          <br /><br />

          In PostgreSQL, the unlogged table could be given a last used attribute but it would require a write during the which feels icky when actually trying to represent a cache. I’m pretty sure Redis and Memcache use a more clever approach and move a recently read identifier from its place in a doubly linked list to the front of it. This allows for constant time updating which I've seen implemented before.

          <br /><br />

          Perhaps I’ll explore later what a last used time could do to make a PostgreSQL cache more LRU like.

          <br /><br />

          Code:

          <br /><br />

          Docker Compose was used to make PostgreSQL with pg_cron, Redis, and Memcached container instances. The container_config folder has the compose.yaml and Dockerfile settings.

          <br /><br />

          The driver for testing was Python since some easy to use libraries for Redis and Memcached exist.

          <br /><br />

          PostgreSQL connecting and SQLAlchemy ORM libraries made commit sessions and database implementation a breeze.

          <br /><br />

          The various caches are organized into classes that rely on a base cache class that make use of Python wacky class inheritance. For example, Python method overrides aren’t verbose in any way but there is a library to achieve that with _.

          <br /><br />

          See. cache.py, and other…

          <br /><br />

          Lastly, the scripts folder contains the various scripts used to generate random trace file data and out an accompanying sql file which Docker postgres can load in its entry point location. The ARC paper trace files are here but not included in the repo. There are some comment lines in places for configuring the ARC paper trace files if it peaks one's interest.

          <br /><br />


        </p>
      </div>

      <p className="read-the-docs">
        Github Pages Website for showcasing projects, blogs, and more
        <br />
        - Paul Basinger
      </p>
    </>

  )
}

export default App
